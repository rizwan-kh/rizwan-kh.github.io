<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Rizwan Khanüë®üèª‚Äçüíª</title><link>https://rizwan-kh.github.io/tags/docker/</link><description>Recent content in docker on Rizwan Khanüë®üèª‚Äçüíª</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 16 Jul 2022 19:39:13 +0400</lastBuildDate><atom:link href="https://rizwan-kh.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Working with dead container</title><link>https://rizwan-kh.github.io/posts/2022/07/working-with-dead-container/</link><pubDate>Sat, 16 Jul 2022 19:39:13 +0400</pubDate><guid>https://rizwan-kh.github.io/posts/2022/07/working-with-dead-container/</guid><description>I came across this question from a team member who wanted to troubleshoot a dead container. I use the below process and I thought why not do a small write-up to help the wider audience?
Usage The process is very simple - to save/commit the dead container to a new image and then start a new container with a sh entrypoint and debug the container. I consider you&amp;rsquo;re using docker, although similar equivalent commands for other container runtime alternatives like podman, ctr, etc.</description></item><item><title>Klar</title><link>https://rizwan-kh.github.io/posts/2020/03/klar/</link><pubDate>Sat, 14 Mar 2020 17:20:26 +0400</pubDate><guid>https://rizwan-kh.github.io/posts/2020/03/klar/</guid><description>Introduction Klar is a static binary tool to analyze images stored in a private or public Docker registry for security vulnerabilities using Clair. Klar is designed to be used as an integration tool so it relies on environment variables. It&amp;rsquo;s a single binary which requires no dependencies and can be plugged and/or integrated into our CI CD pipelines.
Klar serves as a client which coordinates the image checks between the Docker registry and Clair.</description></item><item><title>Gitlab CI &amp; Kaniko to build Docker Images</title><link>https://rizwan-kh.github.io/posts/2020/02/gitlab-ci-kaniko-to-build-docker-images/</link><pubDate>Wed, 12 Feb 2020 12:11:00 +0400</pubDate><guid>https://rizwan-kh.github.io/posts/2020/02/gitlab-ci-kaniko-to-build-docker-images/</guid><description>Introduction You can build container images from a Dockerfile inside a container or a Kubernetes cluster, though J√©r√¥me Petazzoni strongly discourages doing so. He wrote a detailed blog that can be read here on why not to build container images using Dockerfile inside a container or a Kubernetes cluster.
Context You will get N number of blogs on how to use the CI/CD of GitLab; here we will see an easy reference point to extend a file and create CI/CD for Docker Image to be built and stored in the same GitLab registry using kaniko.</description></item><item><title>Docker Cheat Sheet</title><link>https://rizwan-kh.github.io/posts/2019/10/docker-cheat-sheet/</link><pubDate>Fri, 11 Oct 2019 05:11:13 +0400</pubDate><guid>https://rizwan-kh.github.io/posts/2019/10/docker-cheat-sheet/</guid><description>Below are a few of the main and basic commands used in Docker, an easy pick-up and good-to-go command page for docker troubleshooting.
Alias If you are a lazy developer/sysadmin like me, the first thing you should do on your system is to make easy alias of all the long commands, below are the ones I often use on any system I use daily:
These can be imported on ~/.</description></item></channel></rss>